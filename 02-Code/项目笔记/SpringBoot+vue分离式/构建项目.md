# java构建项目模板



## 1 初始构建

### 1.1 初始选择

- Catalog: **Internal**
- Archetype: .maven.archetypes:maven-archetype-**quickstart**

### 1.2 创建包与文件

结构如下

```java
```



### 1.3 pom导入

```java
    <!-- 父工程 -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.13</version>
    </parent>
```

```
<!-- 依赖 -->
<dependencies>
    <!-- 添加web类路径依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

</dependencies>

<!-- 创建可执行的jar程序 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

### 1.4 主函数进行管理

- 在主函数中添加 `@SpringBootApplication` 注释，以及run方法

```java
@SpringBootApplication
public class Main {
    public static void main(String[] args) {
        // Main是函数名，其他不变
        SpringApplication.run(Main.class, args);
        System.out.println("Hello world!");
    }
}
```

## 2 添加常用pom依赖

### 2.2 lombok-Slf4j

```
<!-- lombok -->
<dependency>
  <groupId>org.projectlombok</groupId>
  <artifactId>lombok</artifactId>
  <version>1.18.12</version>
</dependency>
```





## 3 全局配置

###  3.1 跨域问题

- ../config/CorsConfig

```
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                //是否发送Cookie
                .allowCredentials(true)
                //放行哪些原始域
                .allowedOrigins("*")
                .allowedMethods(new String[]{"GET", "POST", "PUT", "DELETE"})
                .allowedHeaders("*")
                .exposedHeaders("*");
    }
}

```



### 3.2 异常处理

> 1. 全局异常处理
> 2. 局部异常处理

#### 全局异常处理

- ../exception/GlobalExceptionHandler.java

```
@ControllerAdvice
public class GlobalExceptionHandler {
    /**
     * @ExceptionHandler相当于controller的@RequestMapping
     * 如果抛出的的是ServiceException，则调用该方法
     * @param se 业务异常
     * @return
     */
    @ExceptionHandler(ServiceException.class)
    @ResponseBody
    public Result handle(ServiceException se){
        return Result.error(se.getCode(), se.getMessage());
    }
}

```



#### 局部异常处理

```
/**
 * RuntimeException是系统运行中的异常
 * 自定义异常
 */
@Data
public class ServiceException extends RuntimeException{
    // 错误码
    private String code;

    public ServiceException(String code, String msg) {
        super(msg);
        this.code = code;
    }
}
```



###  3.3 JWT认证

> 步骤：
>
> ```
>        <dependency>
>             <groupId>io.jsonwebtoken</groupId>
>             <artifactId>jjwt</artifactId>
>             <version>0.9.1</version>
>         </dependency>
> ```
>
> 
>
> 1. 封装jwt工具类
> 2. 创建拦截器，验证token
> 3. 创建注册器注册到springboot

1. **封装jwt工具类**

   - ../utils/JwtUtil

   ```
   @Component
   public class JwtUtil {
       @Value("${token.secretKey}")
       private String secretKey;
       /**
        * 加密token.
        */
       public String getToken(String userId, String userRole) {
           //这个是放到负载payLoad 里面,魔法值可以使用常量类进行封装.
           String token = JWT
                   .create()
                   .withClaim("userId" ,userId)
                   .withClaim("userRole", userRole)
                   .withClaim("timeStamp", System.currentTimeMillis())
                   .sign(Algorithm.HMAC256(secretKey));
           return token;
       }
       /**
        * 解析token.
        * {
        * "userId": "weizhong",
        * "userRole": "ROLE_ADMIN",
        * "timeStamp": "134143214"
        * }
        */
       public Map<String, String> parseToken(String token) {
           HashMap<String, String> map = new HashMap<String, String>();
           DecodedJWT decodedjwt = JWT.require(Algorithm.HMAC256(secretKey))
                   .build().verify(token);
           Claim userId = decodedjwt.getClaim("userId");
           Claim userRole = decodedjwt.getClaim("userRole");
           Claim timeStamp = decodedjwt.getClaim("timeStamp");
           map.put("userId", userId.asString());
           map.put("userRole", userRole.asString());
           map.put("timeStamp", timeStamp.asLong().toString());
           return map;
       }
   }
   ```

   

2. **创建拦截器，验证token**

   - ../interceptor/JwtInterceptor.java

   ```
   @Slf4j
   @Component
   public class AuthHandlerInterceptor implements HandlerInterceptor {
       @Autowired
       TokenUtil tokenUtil;
       @Value("${token.refreshTime}")
       private Long refreshTime;
       @Value("${token.expiresTime}")
       private Long expiresTime;
       /**
        * 权限认证的拦截操作.
        */
       @Override
       public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception {
           log.info("=======进入拦截器========");
           // 如果不是映射到方法直接通过,可以访问资源.
           if (!(object instanceof HandlerMethod)) {
               return true;
           }
           //为空就返回错误
           String token = httpServletRequest.getHeader("token");
           if (null == token || "".equals(token.trim())) {
               return false;
           }
           log.info("==============token:" + token);
           Map<String, String> map = tokenUtil.parseToken(token);
           String userId = map.get("userId");
           String userRole = map.get("userRole");
           long timeOfUse = System.currentTimeMillis() - Long.parseLong(map.get("timeStamp"));
           //1.判断 token 是否过期
           if (timeOfUse < refreshTime) {
               log.info("token验证成功");
               return true;
           }
           //超过token刷新时间，刷新 token
           else if (timeOfUse >= refreshTime && timeOfUse < expiresTime) {
               httpServletResponse.setHeader("token",tokenUtil.getToken(userId,userRole));
               log.info("token刷新成功");
               return true;
           }
           //token过期就返回 token 无效.
           else {
               throw new TokenAuthExpiredException();
           }
       }
   }
   ```

   

3. **创建注册器注册到springboot**

   - ../config/IntercptorConfig

   ````
   package com.org.config;
   
   import com.org.interceptor.JwtInterceptor;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
   
   
   /**
    * 注册
    */
   @Configuration
   public class IntercptorConfig implements WebMvcConfigurer {
       @Override
       public void addInterceptors(InterceptorRegistry registry) {
           registry.addInterceptor(jwtInterceptor())
                   .addPathPatterns("/**")    // 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录
                   .excludePathPatterns("/user/login", "/user/register", "/**/export", "/**/import");
       }
       @Bean
       public JwtInterceptor jwtInterceptor() {
           return new JwtInterceptor();
       }
   }
   
   ````





### 3.4 统一结果类

- ../common/Result.java

```
package com.example.springboot.common;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Result {

    public static final String CODE_SUCCESS = "200";
    public static final String CODE_AUTH_ERROR = "401";
    public static final String CODE_SYS_ERROR = "500";

    private String code;
    private String msg;
    private Object data;


    public static Result success() {
        return new Result(CODE_SUCCESS, "请求成功", null);
    }

    public static Result success(Object data) {
        return new Result(CODE_SUCCESS, "请求成功", data);
    }

    public static Result error(String msg) {
        return new Result(CODE_SYS_ERROR, msg, null);
    }

    public static Result error(String code, String msg) {
        return new Result(code, msg, null);
    }

    public static Result error() {
        return new Result(CODE_SYS_ERROR, "系统错误", null);
    }

}
```







## 基本整合

### mysql

- pom

  ```java
      <!-- mysql驱动依赖 -->
      <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
      </dependency>
  ```

  

- yml

  ```java
  server:
    port: 8080
  spring:
    datasource:
      username: root
      password: 123456
      url: jdbc:mysql://localhost:3306/数据库名?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
      driver-class-name: com.mysql.cj.jdbc.Driver
  ```

### mybatis

- pom

  ```java
      <!-- mybatis -->
      <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>3.0.2</version>
      </dependency>
  ```

  

- yml

  ```java
  # mybatis配置
  mybatis:
    mapper-locations: classpath:mapper/*.xml    # mapper映射文件位置
    type-aliases-package: com.gouggou.shardingtable.entity    # 实体类所在的位置
    configuration:
      log-impl: org.apache.ibatis.logging.stdout.StdOutImpl   #用于控制台打印sql语句
  ```

  > 日常使用第一个即可


### jwt

- pom

  ```
  <!-- JWT -->
  <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt</artifactId>
      <version>0.9.1</version>
  </dependency>
  ```

- 封装类

  ```
  package com.mushan.im.utils;
  
  
  
  
  import com.alibaba.fastjson.JSON;
  import com.mushan.im.pojo.User;
  import io.jsonwebtoken.Claims;
  import io.jsonwebtoken.JwtBuilder;
  import io.jsonwebtoken.Jwts;
  import io.jsonwebtoken.SignatureAlgorithm;
  import org.springframework.stereotype.Component;
  
  import java.util.*;
  
  @Component
  public class JwtUtil {
  
     /**
       * 用户登录成功后生成Jwt
       * 使用Hs256算法  私匙使用用户密码
       *
       * @return
       */
      public  String createJWT(User user) {
          Map<String, Object> map = new HashMap<>();
          map.put("user",user);
          return generatorToken(map);
      }
  
      private String generatorToken(Map<String, Object> map) {
          return Jwts.builder().setClaims(map)
                  .setExpiration(generatorExpiration())
                  .signWith(SignatureAlgorithm.HS512, "232312fjwaijfoa")
                  .compact();
      }
  
      public User getToken(String token){
          Claims body = Jwts.parser().setSigningKey("232312fjwaijfoa").parseClaimsJws(token).getBody();
          LinkedHashMap user = (LinkedHashMap) body.get("user");
          return JSON.parseObject(JSON.toJSONString(user), User.class);
      }
  
      private Date generatorExpiration() {
          return new Date(System.currentTimeMillis() + 9000000);
      }
  
  }
  ```

  

- yml

  ```
  jwt:
    tokenHeader: Authorization
    secret: eiorjeowijfioewjfdksjfoisd
    expiration: 1800000
    tokenHead: Bearer
  ```

  

###  
