# 1 环境搭建

## 1.1 nacos

### 1.1.1 nacos安装

①：docker拉取镜像 

```shell
docker pull nacos/nacos-server:1.2.0
```

②：创建容器

```shell
docker run --env MODE=standalone --name nacos --restart=always  -d -p 8848:8848 nacos/nacos-server:1.2.0
```

- MODE=standalone 单机版

- --restart=always 开机启动

- -p 8848:8848  映射端口

- -d 创建一个守护式容器在后台运行

③：访问地址：http://192.168.200.130:8848/nacos 



### 1.1.2 nacos注册中心统一配置

> 知识点可以查看[4.1 nacos配置管理](../../基础/后端/Java/微服务框架/SpringCloud/SpringCloud.md)

1. 引导类

   > 主要是添加注解@EnableDiscoveryClient
   >
   > 还有mapper映射，但是这个是mybatis-plus需要的

2. bootstrap.yml

   > 这个是引导文件，这个读取优先级高于application.yml

3. 在nacos中创建配置文件

   > 直接添加该模块的配置类即可
   >
   > 这里需要说明一下，其实user和service中是没有mybatis-plus依赖的，但是他们引入了含有该依赖的model模块，所以说是可以使用mybatis-plus依赖的，这个是javaweb的东西。

4. logback.xml

   > ```
   > <?xml version="1.0" encoding="UTF-8"?>
   > 
   > <configuration>
   >     <!--定义日志文件的存储地址,使用绝对路径-->
   >     <property name="LOG_HOME" value="e:/logs"/>
   > 
   >     <!-- Console 输出设置 -->
   >     <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
   >         <encoder>
   >             <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
   >             <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
   >             <charset>utf8</charset>
   >         </encoder>
   >     </appender>
   > 
   >     <!-- 按照每天生成日志文件 -->
   >     <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
   >         <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
   >             <!--日志文件输出的文件名-->
   >             <fileNamePattern>${LOG_HOME}/leadnews.%d{yyyy-MM-dd}.log</fileNamePattern>
   >         </rollingPolicy>
   >         <encoder>
   >             <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
   >         </encoder>
   >     </appender>
   > 
   >     <!-- 异步输出 -->
   >     <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
   >         <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
   >         <discardingThreshold>0</discardingThreshold>
   >         <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
   >         <queueSize>512</queueSize>
   >         <!-- 添加附加的appender,最多只能添加一个 -->
   >         <appender-ref ref="FILE"/>
   >     </appender>
   > 
   > 
   >     <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
   >         <appender-ref ref="CONSOLE"/>
   >     </logger>
   >     <logger name="org.springframework.boot" level="debug"/>
   >     <root level="info">
   >         <!--<appender-ref ref="ASYNC"/>-->
   >         <appender-ref ref="FILE"/>
   >         <appender-ref ref="CONSOLE"/>
   >     </root>
   > </configuration>
   > ```
   >
   > 这里配置的是logback文件，有两个注意点
   >
   > 1. 输出
   >
   >    > ```
   >    > <!--定义日志文件的存储地址,使用绝对路径-->
   >    > <property name="LOG_HOME" value="e:/logs"/>
   >    > ```
   >
   > 2. 开发的时候尽量使用debug
   >
   >    ```
   >    <logger name="org.springframework.boot" level="debug"/>
   >    ```



### 1.1.3 spring.factories介绍

> src/main/resources/META-INF/spring.factories地址是这个，它可以在springboot扫描的时候进行扫面一般来说是一些配置类如下：
>
> > ```
> > org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
> >   com.heima.common.exception.ExceptionCatch,\
> >   com.heima.common.swagger.SwaggerConfiguration
> > ```

## 1.2 网关



### 1.2.1 网关搭建

> 步骤：
>
> 1. （1）在heima-leadnews-gateway导入以下依赖
> 2. （2）在heima-leadnews-gateway下创建heima-leadnews-app-gateway微服务
>    1. 引导类
>    2. bootstrap
>    3. 在nacos的配置中心创建dataid为leadnews-app-gateway的yml配置

**（1）在heima-leadnews-gateway导入以下依赖**

pom文件

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
     <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
    </dependency>
</dependencies>
```

**（2）在heima-leadnews-gateway下创建heima-leadnews-app-gateway微服务**

**引导类：**

```java
package com.heima.app.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient  //开启注册中心
public class AppGatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(AppGatewayApplication.class,args);
    }
}
```

**bootstrap.yml**

```yaml
server:
  port: 51601
spring:
  application:
    name: leadnews-app-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.200.130:8848
      config:
        server-addr: 192.168.200.130:8848
        file-extension: yml
```

**在nacos的配置中心创建dataid为leadnews-app-gateway的yml配置**

```yaml
spring:
  cloud:
    gateway:
      globalcors:
        add-to-simple-url-handler-mapping: true
        corsConfigurations:
          '[/**]':
            allowedHeaders: "*"
            allowedOrigins: "*"
            allowedMethods:
              - GET
              - POST
              - DELETE
              - PUT
              - OPTION
      routes:
        # 平台管理
        - id: user
          uri: lb://leadnews-user
          predicates:
            - Path=/user/**
          filters:
            - StripPrefix= 1
```



环境搭建完成以后，启动项目网关和用户两个服务，使用postman进行测试

请求地址：http://localhost:51601/user/api/v1/login/login_auth   



### 1.2.2 网关校验jwt

![image-20240114222833636](./assets/image-20240114222833636.png)



步骤：

> 1. 引入依赖
> 2. 创建全局过滤器并进行过滤

1. **引入依赖**

   > 在搭建的时候已经导入过了（注意是gateway父工程，），jwt的依赖即可

2. **创建全局过滤器并进行过滤**

   - 路径com.eason.app.gateway.filter.AuthorizeFilter

   ```java
   package com.eason.app.gateway.filter;
   
   import com.eason.app.gateway.util.AppJwtUtil;
   import io.jsonwebtoken.Claims;
   import lombok.extern.slf4j.Slf4j;
   import org.apache.commons.lang.StringUtils;
   import org.springframework.cloud.gateway.filter.GatewayFilterChain;
   import org.springframework.cloud.gateway.filter.GlobalFilter;
   import org.springframework.core.Ordered;
   import org.springframework.http.HttpStatus;
   import org.springframework.http.server.reactive.ServerHttpRequest;
   import org.springframework.http.server.reactive.ServerHttpResponse;
   import org.springframework.stereotype.Component;
   import org.springframework.web.server.ServerWebExchange;
   import reactor.core.publisher.Mono;
   
   @Component
   @Slf4j
   public class AuthorizeFilter implements Ordered, GlobalFilter {
   
       @Override
       public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
           // 1 获取request和response对象
           ServerHttpRequest request = exchange.getRequest();
           ServerHttpResponse response = exchange.getResponse();
           String url = request.getURI().toString();
           // 2 判断是否是登录
           if (url.contains("login")) {
               // 放行
               System.out.println("拦截到login");
               return chain.filter(exchange);
           }
           // 3 获取token
           String token = request.getHeaders().getFirst("token");
           // 4 判断token是否存在
           if (StringUtils.isBlank(token)) {
               response.setStatusCode(HttpStatus.UNAUTHORIZED);
               return response.setComplete();
           }
           // 5 判断token是否有效
           try {
               Claims claimsBody = AppJwtUtil.getClaimsBody(token);
               // 是否过期
               int result = AppJwtUtil.verifyToken(claimsBody);
               if (result ==1 | result == 2) {
                   response.setStatusCode(HttpStatus.UNAUTHORIZED);
                   return response.setComplete();
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
   
           System.out.println("所有都运行完毕");
           // 6 放行
           return chain.filter(exchange);
       }
   
       /**
        * 优先级设置、 值越小、 优先级越高
        * @return
        */
       @Override
       public int getOrder() {
           return 0;
       }
   }
   ```

   > 这里需要说的是实现两个接口，其他都一样了。就是正常过程



## 1.3 整合Knife4j

> 这个就结合了1.1.3的spring.factories
>
> 步骤：
>
> 1. 导入依赖
> 2. 创建配置文件
> 3. 在Spring.factories中新增配置

1. **导入依赖**

   在heima-leadnews-common模块中的`pom.xml`文件中引入`knife4j`的依赖,如下：

   ```java
   <dependency>
        <groupId>com.github.xiaoymin</groupId>
        <artifactId>knife4j-spring-boot-starter</artifactId>
   </dependency>
   ```

   

2. **创建配置文件**

   在heima-leadnews-common模块中新建配置类

   新建Swagger的配置文件`SwaggerConfiguration.java`文件,创建springfox提供的Docket分组对象,代码如下：

   ```java
   package com.heima.common.swagger;
   
   import com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;
   import lombok.var;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.context.annotation.Import;
   import springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;
   import springfox.documentation.builders.ApiInfoBuilder;
   import springfox.documentation.builders.PathSelectors;
   import springfox.documentation.builders.RequestHandlerSelectors;
   import springfox.documentation.service.ApiInfo;
   import springfox.documentation.spi.DocumentationType;
   import springfox.documentation.spring.web.plugins.Docket;
   import springfox.documentation.swagger2.annotations.EnableSwagger2;
   
   @Configuration
   @EnableSwagger2
   @EnableKnife4j
   @Import(BeanValidatorPluginsConfiguration.class)
   public class SwaggerConfiguration {
   
       @Bean(value = "defaultApi2")
       public Docket defaultApi2() {
           var docket = new Docket(DocumentationType.SWAGGER_2)
                   .apiInfo(apiInfo())
                   // 分组名称
                   .groupName("1.0")
                   .select()
                   // 这里指定Controller扫描包路径
                   .apis(RequestHandlerSelectors.basePackage("com.eason"))
                   .paths(PathSelectors.any())
                   .build();
           return docket;
       }
       private ApiInfo apiInfo() {
           return new ApiInfoBuilder()
                   .title("闻讯头条API文档")
                   .description("闻讯头条API文档")
                   .version("1.0")
                   .build();
       }
   }
   ```

   

3. **在Spring.factories中新增配置**

   ```java
   org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
   com.heima.common.exception.ExceptionCatch,\
   com.heima.common.swagger.SwaggerConfiguration
   ```

   - 访问

   在浏览器输入地址：`http://host:port/doc.html`



# 2 业务分析

## 2.1 登录

### 2.1.1 密码加密

> 引入了`密码+salt`md5加密，即数据库添加一个字段salt(字符串)。
>
> - 用户注册：密码+生成的字符串（salt）进行md5加密
>
> - 用户登录：先通过用户名进行查询salt字段和输入密码进行md5加密后对比数据库md5密码。

### 2.1.2 游客登录

> 1，用户输入了用户名和密码进行登录，校验成功后返回jwt(基于当前用户的id生成)
>
> 2，用户游客登录，生成jwt返回(基于默认值0生成)





## 2.2 app端

### 2.2.1 文章查看

> 思路：
>
> ![image-20210419152011931](./assets/image-20210419152011931.png)
>
> 1,在默认频道展示10条文章信息 -> 按照时间的倒叙进行排序
>
> 2,可以切换频道查看不同种类文章 -> 频道是id，一个条件语句即可
>
> 3,当用户下拉可以加载最新的文章（分页）本页文章列表中发布时间为最大的时间为依据 -> 是按照时间倒叙
>
> 4,当用户上拉可以加载更多的文章信息（按照发布时间）本页文章列表中发布时间最小的时间为依据 
>
> 5，如果是当前频道的首页，前端传递默认参数：
>
> - maxBehotTime：0（毫秒）
>
> - minBehotTime：20000000000000（毫秒）--->2063年

> ```sql
> # 按照发布时间倒叙查询10条文章数据
> select * from ap_article aa ORDER BY aa.publish_time DESC LIMIT 10
> 
> 
> # 查询频道顺序
> select * from ap_article aa WHERE aa.channel_id = 1 ORDER BY aa.publish_time DESC LIMIT 10
> 
> # 加载首页
> select * from ap_article aa WHERE aa.channel_id=1 and aa.publish_time < '2063-04-19 00:20:17' ORDER BY aa.publish_time DESC LIMIT 10
> 
> ```
>
> > 这里其实是将文件
>
> 这里需要说明一下：在mybatis中小于号需要进行转码 <![CDATA[<]]>这个就是小于号，防止被xml识别
>
> ```mysql
> <if test="type != null and type == 1">
>     and aa.publish_time <![CDATA[<]]> #{dto.minBehotTime}
> </if>
> ```

### 2.2.2 服务进行的步骤（从创建到完整的模块）

> 步骤：
>
> 1. 创建模块
> 2. 添加nacos配置和boostrap文件
> 3. 正常编写业务
> 4. 在nacos网关配置进行添加相关配置



1. **创建模块**

   > 在service二级模块下面创建heima-leadnews\heima-leadnews-service\eason-leadnews-article
   >
   > 这里heima-leadnews是项目名字，heima-leadnews-service是二级模块
   >
   > 这里可以导入，然后右边或者模块的maven可以进行pom文件导入将普通文件转换为模块

2. **添加nacos配置和boostrap文件**

   - **nacos**

     ```yaml
     spring:
       datasource:
         driver-class-name: com.mysql.jdbc.Driver
         url: jdbc:mysql://localhost:3306/leadnews_article?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&serverTimezone=GMT%2B8&useSSL=false
         username: root
         password: 123456
     # 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
     mybatis-plus:
       mapper-locations: classpath*:mapper/*.xml
       # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
       type-aliases-package: com.eason.model.article.pojos
     ```

   - **boostrap**

     ```yaml
     server:
       port: 51802
     spring:
       application:
         name: leadnews-article
       cloud:
         nacos:
           discovery:
             server-addr: 192.168.47.128:8848
           config:
             server-addr: 192.168.47.128:8848
             file-extension: yml
     ```

     > 这里面基本一样，引入nacos，name是命名，自定义的模块名

3. **正常编写业务**

   > 这里有个很奇怪的现象，pom文件需要引入junit才能用knife4j，这个很奇怪

4. **在nacos网关配置进行添加相关配置**

   > ```yaml
   >         # 文章微服务
   >         - id: article
   >           uri: lb://leadnews-article
   >           predicates:
   >             - Path=/article/**
   >           filters:
   >             - StripPrefix= 1
   > ```
   >
   > > 这是需要添加的，完整的网关文件上面的[网关搭建](# 1.2.1 网关搭建)步骤有



# 3 新技术

## 3.1 freemarker

### 3.1.1 freemarker介绍

​	FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。

​	模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， *不是* 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。 

![1528820943975](./assets/1528820943975-1705334641761-2.png)

### 3.1.2 freemarker入门

> freemarker作为springmvc一种视图格式，默认情况下SpringMVC支持freemarker视图格式。
>
> 需要创建Spring Boot+Freemarker工程用于测试模板。

> 1. 创建测试工程
> 2. 配置文件
> 3. 创建模型类
> 4. 创建模板
> 5. 创建controller
> 6. 创建启动类
> 7. 测试

1. **创建测试工程**

   创建一个freemarker-demo 的测试工程专门用于freemarker的功能测试与模板的测试。

   pom.xml如下

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <project xmlns="http://maven.apache.org/POM/4.0.0"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
       <parent>
           <artifactId>heima-leadnews-test</artifactId>
           <groupId>com.heima</groupId>
           <version>1.0-SNAPSHOT</version>
       </parent>
       <modelVersion>4.0.0</modelVersion>
   
       <artifactId>freemarker-demo</artifactId>
   
       <properties>
           <maven.compiler.source>8</maven.compiler.source>
           <maven.compiler.target>8</maven.compiler.target>
       </properties>
   
       <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-freemarker</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-test</artifactId>
           </dependency>
           <!-- lombok -->
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
           </dependency>
   
           <!-- apache 对 java io 的封装工具库 -->
           <dependency>
               <groupId>org.apache.commons</groupId>
               <artifactId>commons-io</artifactId>
               <version>1.3.2</version>
           </dependency>
       </dependencies>
   
   </project>
   ```

2. **配置文件**

   配置application.yml

   ```yaml
   server:
     port: 8881 #服务端口
   spring:
     application:
       name: freemarker-demo #指定服务名
     freemarker:
       cache: false  #关闭模板缓存，方便测试
       settings:
         template_update_delay: 0 #检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试
       suffix: .ftl               #指定Freemarker模板文件的后缀名
   ```

3. **创建模型类**

   在freemarker的测试工程下创建模型类型用于测试

   

   ```java
   package com.heima.freemarker.entity;
   
   import lombok.Data;
   
   import java.util.Date;
   
   @Data
   public class Student {
       private String name;//姓名
       private int age;//年龄
       private Date birthday;//生日
       private Float money;//钱包
   }
   ```

4. **创建模板**

   在resources下创建templates，此目录为freemarker的默认模板存放目录。

   在templates下创建模板文件 01-basic.ftl ，模板中的插值表达式最终会被freemarker替换成具体的数据。

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="utf-8">
       <title>Hello World!</title>
   </head>
   <body>
   <b>普通文本 String 展示：</b><br><br>
   Hello ${name} <br>
   <hr>
   <b>对象Student中的数据展示：</b><br/>
   姓名：${stu.name}<br/>
   年龄：${stu.age}
   <hr>
   </body>
   </html>
   ```

   

5. **创建controller**

   创建Controller类，向Map中添加name，最后返回模板文件。

   ```java
   package com.xuecheng.test.freemarker.controller;
   
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.client.RestTemplate;
   
   import java.util.Map;
   
   @Controller
   public class HelloController {
   
       @GetMapping("/basic")
       public String test(Model model) {
   
   
           //1.纯文本形式的参数
           model.addAttribute("name", "freemarker");
           //2.实体类相关的参数
           
           Student student = new Student();
           student.setName("小明");
           student.setAge(18);
           model.addAttribute("stu", student);
   
           return "01-basic";
       }
   }
   ```

   01-basic.ftl，使用插值表达式填充数据

6. **创建启动类**

   ```java
   package com.heima.freemarker;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class FreemarkerDemotApplication {
       public static void main(String[] args) {
           SpringApplication.run(FreemarkerDemotApplication.class,args);
       }
   }
   ```

   

7. **测试**

   请求：http://localhost:8881/basic

3.1.3 freemarker基础

> 1. 基础语法种类
> 2. 集合指令（list和map）
> 3. if指令
> 4. 运算符
> 5. 空值处理
> 6. 内建函数

1. **基础语法种类**

    1、注释，即<#--  -->，介于其之间的内容会被freemarker忽略

   ```velocity
   <#--我是一个freemarker注释-->
   ```

     2、插值（Interpolation）：即 **`${..}`** 部分,freemarker会用真实的值代替**`${..}`**

   ```velocity
   Hello ${name}
   ```

     3、FTL指令：和HTML标记类似，名字前加#予以区分，Freemarker会解析标签中的表达式或逻辑。

   ```velocity
   <# >FTL指令</#> 
   ```

     4、文本，仅文本信息，这些不是freemarker的注释、插值、FTL指令的内容会被freemarker忽略解析，直接输出内容。

   ```velocity
   <#--freemarker中的普通文本-->
   我是一个普通的文本
   ```

2. **集合指令（list和map）**

   1、数据模型：

   在HelloController中新增如下方法：

   ```java
   @GetMapping("/list")
   public String list(Model model){
   
       //------------------------------------
       Student stu1 = new Student();
       stu1.setName("小强");
       stu1.setAge(18);
       stu1.setMoney(1000.86f);
       stu1.setBirthday(new Date());
   
       //小红对象模型数据
       Student stu2 = new Student();
       stu2.setName("小红");
       stu2.setMoney(200.1f);
       stu2.setAge(19);
   
       //将两个对象模型数据存放到List集合中
       List<Student> stus = new ArrayList<>();
       stus.add(stu1);
       stus.add(stu2);
   
       //向model中存放List集合数据
       model.addAttribute("stus",stus);
   
       //------------------------------------
   
       //创建Map数据
       HashMap<String,Student> stuMap = new HashMap<>();
       stuMap.put("stu1",stu1);
       stuMap.put("stu2",stu2);
       // 3.1 向model中存放Map数据
       model.addAttribute("stuMap", stuMap);
   
       return "02-list";
   }
   ```

   2、模板：

   在templates中新增`02-list.ftl`文件

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="utf-8">
       <title>Hello World!</title>
   </head>
   <body>
       
   <#-- list 数据的展示 -->
   <b>展示list中的stu数据:</b>
   <br>
   <br>
   <table>
       <tr>
           <td>序号</td>
           <td>姓名</td>
           <td>年龄</td>
           <td>钱包</td>
       </tr>
   </table>
   <hr>
       
   <#-- Map 数据的展示 -->
   <b>map数据的展示：</b>
   <br/><br/>
   <a href="###">方式一：通过map['keyname'].property</a><br/>
   输出stu1的学生信息：<br/>
   姓名：<br/>
   年龄：<br/>
   <br/>
   <a href="###">方式二：通过map.keyname.property</a><br/>
   输出stu2的学生信息：<br/>
   姓名：<br/>
   年龄：<br/>
   
   <br/>
   <a href="###">遍历map中两个学生信息：</a><br/>
   <table>
       <tr>
           <td>序号</td>
           <td>姓名</td>
           <td>年龄</td>
           <td>钱包</td> 
       </tr>
   </table>
   <hr>
    
   </body>
   </html>
   ```

   实例代码：

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="utf-8">
       <title>Hello World!</title>
   </head>
   <body>
       
   <#-- list 数据的展示 -->
   <b>展示list中的stu数据:</b>
   <br>
   <br>
   <table>
       <tr>
           <td>序号</td>
           <td>姓名</td>
           <td>年龄</td>
           <td>钱包</td>
       </tr>
       <#list stus as stu>
           <tr>
               <td>${stu_index+1}</td>
               <td>${stu.name}</td>
               <td>${stu.age}</td>
               <td>${stu.money}</td>
           </tr>
       </#list>
   
   </table>
   <hr>
       
   <#-- Map 数据的展示 -->
   <b>map数据的展示：</b>
   <br/><br/>
   <a href="###">方式一：通过map['keyname'].property</a><br/>
   输出stu1的学生信息：<br/>
   姓名：${stuMap['stu1'].name}<br/>
   年龄：${stuMap['stu1'].age}<br/>
   <br/>
   <a href="###">方式二：通过map.keyname.property</a><br/>
   输出stu2的学生信息：<br/>
   姓名：${stuMap.stu2.name}<br/>
   年龄：${stuMap.stu2.age}<br/>
   
   <br/>
   <a href="###">遍历map中两个学生信息：</a><br/>
   <table>
       <tr>
           <td>序号</td>
           <td>姓名</td>
           <td>年龄</td>
           <td>钱包</td>
       </tr>
       <#list stuMap?keys as key >
           <tr>
               <td>${key_index}</td>
               <td>${stuMap[key].name}</td>
               <td>${stuMap[key].age}</td>
               <td>${stuMap[key].money}</td>
           </tr>
       </#list>
   </table>
   <hr>
    
   </body>
   </html>
   ```

   👆上面代码解释：

   ${k_index}：
   	index：得到循环的下标，使用方法是在stu后边加"_index"，它的值是从0开始

   

3. **if指令**

   ​	 if 指令即判断指令，是常用的FTL指令，freemarker在解析时遇到if会进行判断，条件为真则输出if中间的内容，否则跳过内容不再输出。

   - 指令格式

   ```html
   <#if ></if>
   ```

   

   1、数据模型：

   使用list指令中测试数据模型，判断名称为小红的数据字体显示为红色。

   2、模板：

   ```velocity
   <table>
       <tr>
           <td>姓名</td>
           <td>年龄</td>
           <td>钱包</td>
       </tr>
       <#list stus as stu>
           <tr>
               <td >${stu.name}</td>
               <td>${stu.age}</td>
               <td >${stu.mondy}</td>
           </tr>
       </#list>
   
   </table>
   ```

   

   实例代码：

   ```velocity
   <table>
       <tr>
           <td>姓名</td>
           <td>年龄</td>
           <td>钱包</td>
       </tr>
       <#list stus as stu >
           <#if stu.name='小红'>
               <tr style="color: red">
                   <td>${stu_index}</td>
                   <td>${stu.name}</td>
                   <td>${stu.age}</td>
                   <td>${stu.money}</td>
               </tr>
               <#else >
               <tr>
                   <td>${stu_index}</td>
                   <td>${stu.name}</td>
                   <td>${stu.age}</td>
                   <td>${stu.money}</td>
               </tr>
           </#if>
       </#list>
   </table>
   ```

   > FTL中= 和 == 一样

   

   3、输出：

   姓名为“小红”的字体颜色显示为红色。

4. **运算符**

   **1、算数运算符**

   FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:

   - 加法： `+`
   - 减法： `-`
   - 乘法： `*`
   - 除法： `/`
   - 求模 (求余)： `%`

   

   模板代码

   ```html
   <b>算数运算符</b>
   <br/><br/>
       100+5 运算：  ${100 + 5 }<br/>
       100 - 5 * 5运算：${100 - 5 * 5}<br/>
       5 / 2运算：${5 / 2}<br/>
       12 % 10运算：${12 % 10}<br/>
   <hr>
   ```

   除了 + 运算以外，其他的运算只能和 number 数字类型的计算。

   

   

   

   **2、比较运算符**

   - **`=`**或者**`==`**:判断两个值是否相等. 
   - **`!=`**:判断两个值是否不等. 
   - **`>`**或者**`gt`**:判断左边值是否大于右边值 
   - **`>=`**或者**`gte`**:判断左边值是否大于等于右边值 
   - **`<`**或者**`lt`**:判断左边值是否小于右边值 
   - **`<=`**或者**`lte`**:判断左边值是否小于等于右边值 

   

   = 和 == 模板代码

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="utf-8">
       <title>Hello World!</title>
   </head>
   <body>
   
       <b>比较运算符</b>
       <br/>
       <br/>
   
       <dl>
           <dt> =/== 和 != 比较：</dt>
           <dd>
               <#if "xiaoming" == "xiaoming">
                   字符串的比较 "xiaoming" == "xiaoming"
               </#if>
           </dd>
           <dd>
               <#if 10 != 100>
                   数值的比较 10 != 100
               </#if>
           </dd>
       </dl>
   
   
   
       <dl>
           <dt>其他比较</dt>
           <dd>
               <#if 10 gt 5 >
                   形式一：使用特殊字符比较数值 10 gt 5
               </#if>
           </dd>
           <dd>
               <#-- 日期的比较需要通过?date将属性转为data类型才能进行比较 -->
               <#if (date1?date >= date2?date)>
                   形式二：使用括号形式比较时间 date1?date >= date2?date
               </#if>
           </dd>
       </dl>
   
       <br/>
   <hr>
   </body>
   </html>
   ```

   Controller 的 数据模型代码

   ```java
   @GetMapping("operation")
   public String testOperation(Model model) {
       //构建 Date 数据
       Date now = new Date();
       model.addAttribute("date1", now);
       model.addAttribute("date2", now);
       
       return "03-operation";
   }
   ```

   

   **比较运算符注意**

   - **`=`**和**`!=`**可以用于字符串、数值和日期来比较是否相等
   - **`=`**和**`!=`**两边必须是相同类型的值,否则会产生错误
   - 字符串 **`"x"`** 、**`"x "`** 、**`"X"`**比较是不等的.因为FreeMarker是精确比较
   - 其它的运行符可以作用于数字和日期,但不能作用于字符串
   - 使用**`gt`**等字母运算符代替**`>`**会有更好的效果,因为 FreeMarker会把**`>`**解释成FTL标签的结束字符
   - 可以使用括号来避免这种情况,如:**`<#if (x>y)>`**

   

   

   **3、逻辑运算符**

   - 逻辑与:&& 
   - 逻辑或:|| 
   - 逻辑非:! 

   逻辑运算符只能作用于布尔值,否则将产生错误 。

   

   模板代码

   ```html
   <b>逻辑运算符</b>
       <br/>
       <br/>
       <#if (10 lt 12 )&&( 10  gt  5 )  >
           (10 lt 12 )&&( 10  gt  5 )  显示为 true
       </#if>
       <br/>
       <br/>
       <#if !false>
           false 取反为true
       </#if>
   <hr>
   ```

   

5. **空值处理**

   **1、判断某变量是否存在使用 “??”**

   用法为:variable??,如果该变量存在,返回true,否则返回false 

   例：为防止stus为空报错可以加上判断如下：

   ```velocity
       <#if stus??>
       <#list stus as stu>
       	......
       </#list>
       </#if>
   ```

   

   **2、缺失变量默认值使用 “!”**

   - 使用!要以指定一个默认值，当变量为空时显示默认值

     例：  ${name!''}表示如果name为空显示空字符串。

   

   - 如果是嵌套对象则建议使用（）括起来

     例： ${(stu.bestFriend.name)!''}表示，如果stu或bestFriend或name为空默认显示空字符串。

   

6. **内建函数**

   内建函数语法格式： **`变量+?+函数名称`**  

   **1、和到某个集合的大小**

   **`${集合名?size}`**

   

   **2、日期格式化**

   显示年月日: **`${today?date}`** 
   显示时分秒：**`${today?time}`**   
   显示日期+时间：**`${today?datetime}`**   
   自定义格式化：  **`${today?string("yyyy年MM月")}`**

   

   **3、内建函数`c`**

   model.addAttribute("point", 102920122);

   point是数字型，使用${point}会显示这个数字的值，每三位使用逗号分隔。

   如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出

   **`${point?c}`**

   

   **4、将json字符串转成对象**

   一个例子：

   其中用到了 assign标签，assign的作用是定义一个变量。

   ```velocity
   <#assign text="{'bank':'工商银行','account':'10101920201920212'}" />
   <#assign data=text?eval />
   开户行：${data.bank}  账号：${data.account}
   ```

   

   模板代码：

   ````HTML
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="utf-8">
       <title>inner Function</title>
   </head>
   <body>
   
       <b>获得集合大小</b><br>
   
       集合大小：
       <hr>
   
   
       <b>获得日期</b><br>
   
       显示年月日:      <br>
   
       显示时分秒：<br>
   
       显示日期+时间：<br>
   
       自定义格式化：  <br>
   
       <hr>
   
       <b>内建函数C</b><br>
       没有C函数显示的数值： <br>
   
       有C函数显示的数值：
   
       <hr>
   
       <b>声明变量assign</b><br>
   
   
   <hr>
   </body>
   </html>
   ````

   

   

   内建函数模板页面：

   ```velocity
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="utf-8">
       <title>inner Function</title>
   </head>
   <body>
   
       <b>获得集合大小</b><br>
   
       集合大小：${stus?size}
       <hr>
   
   
       <b>获得日期</b><br>
   
       显示年月日: ${today?date}       <br>
   
       显示时分秒：${today?time}<br>
   
       显示日期+时间：${today?datetime}<br>
   
       自定义格式化：  ${today?string("yyyy年MM月")}<br>
   
       <hr>
   
       <b>内建函数C</b><br>
       没有C函数显示的数值：${point} <br>
   
       有C函数显示的数值：${point?c}
   
       <hr>
   
       <b>声明变量assign</b><br>
       <#assign text="{'bank':'工商银行','account':'10101920201920212'}" />
       <#assign data=text?eval />
       开户行：${data.bank}  账号：${data.account}
   
   <hr>
   </body>
   </html>
   ```

   内建函数Controller数据模型：

   ```java
   @GetMapping("innerFunc")
   public String testInnerFunc(Model model) {
       //1.1 小强对象模型数据
       Student stu1 = new Student();
       stu1.setName("小强");
       stu1.setAge(18);
       stu1.setMoney(1000.86f);
       stu1.setBirthday(new Date());
       //1.2 小红对象模型数据
       Student stu2 = new Student();
       stu2.setName("小红");
       stu2.setMoney(200.1f);
       stu2.setAge(19);
       //1.3 将两个对象模型数据存放到List集合中
       List<Student> stus = new ArrayList<>();
       stus.add(stu1);
       stus.add(stu2);
       model.addAttribute("stus", stus);
       // 2.1 添加日期
       Date date = new Date();
       model.addAttribute("today", date);
       // 3.1 添加数值
       model.addAttribute("point", 102920122);
       return "04-innerFunc";
   }
   ```

   

   

### 3.1.4 静态化测试

> 1. 需求分析
> 2. 静态化测试

1. **需求分析**

   使用freemarker原生Api将页面生成html文件，本节测试html文件生成的方法：

2. **静态化测试**

   根据模板文件生成html文件

   ①：修改application.yml文件，添加以下模板存放位置的配置信息，完整配置如下：

   ```yaml
   server:
     port: 8881 #服务端口
   spring:
     application:
       name: freemarker-demo #指定服务名
     freemarker:
       cache: false  #关闭模板缓存，方便测试
       settings:
         template_update_delay: 0 #检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试
       suffix: .ftl               #指定Freemarker模板文件的后缀名
       template-loader-path: classpath:/templates   #模板存放位置
   ```

   ②：在test下创建测试类

   ```java
   package com.heima.freemarker.test;
   
   
   import com.heima.freemarker.FreemarkerDemoApplication;
   import com.heima.freemarker.entity.Student;
   import freemarker.template.Configuration;
   import freemarker.template.Template;
   import freemarker.template.TemplateException;
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   
   import java.io.FileWriter;
   import java.io.IOException;
   import java.util.*;
   
   @SpringBootTest(classes = FreemarkerDemoApplication.class)
   @RunWith(SpringRunner.class)
   public class FreemarkerTest {
   
       @Autowired
       private Configuration configuration;
   
       @Test
       public void test() throws IOException, TemplateException {
           //freemarker的模板对象，获取模板
           Template template = configuration.getTemplate("02-list.ftl");
           Map params = getData();
           //合成
           //第一个参数 数据模型
           //第二个参数  输出流
           template.process(params, new FileWriter("d:/list.html"));
       }
   
       private Map getData() {
           Map<String, Object> map = new HashMap<>();
   
           //小强对象模型数据
           Student stu1 = new Student();
           stu1.setName("小强");
           stu1.setAge(18);
           stu1.setMoney(1000.86f);
           stu1.setBirthday(new Date());
   
           //小红对象模型数据
           Student stu2 = new Student();
           stu2.setName("小红");
           stu2.setMoney(200.1f);
           stu2.setAge(19);
   
           //将两个对象模型数据存放到List集合中
           List<Student> stus = new ArrayList<>();
           stus.add(stu1);
           stus.add(stu2);
   
           //向map中存放List集合数据
           map.put("stus", stus);
   
   
           //创建Map数据
           HashMap<String, Student> stuMap = new HashMap<>();
           stuMap.put("stu1", stu1);
           stuMap.put("stu2", stu2);
           //向map中存放Map数据
           map.put("stuMap", stuMap);
   
           //返回Map
           return map;
       }
   }
   ```

   

## 3.2 MinIO

### 3.2.1 MinIO简介与特点

1. **简介**

   > MinIO基于Apache License v2.0开源协议的对象存储服务，可以做为云存储的解决方案用来保存海量的图片，视频，文档。由于采用Golang实现，服务端可以工作在Windows,Linux, OS X和FreeBSD上。配置简单，基本是复制可执行程序，单行命令可以运行起来。
   >
   > MinIO兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。
   >
   > **S3 （ Simple Storage Service简单存储服务）**
   >
   > 基本概念
   >
   > - bucket – 类比于文件系统的目录
   > - Object – 类比文件系统的文件
   > - Keys – 类比文件名
   >
   > 官网文档：http://docs.minio.org.cn/docs/

2. **特点**

   > - 数据保护
   >
   >   Minio使用Minio Erasure Code（纠删码）来防止硬件故障。即便损坏一半以上的driver，但是仍然可以从中恢复。
   >
   > - 高性能
   >
   >   作为高性能对象存储，在标准硬件条件下它能达到55GB/s的读、35GB/s的写速率
   >
   > - 可扩容
   >
   >   不同MinIO集群可以组成联邦，并形成一个全局的命名空间，并跨越多个数据中心
   >
   > - SDK支持
   >
   >   基于Minio轻量的特点，它得到类似Java、Python或Go等语言的sdk支持
   >
   > - 有操作页面
   >
   >   面向用户友好的简单操作界面，非常方便的管理Bucket及里面的文件资源
   >
   > - 功能简单
   >
   >   这一设计原则让MinIO不容易出错、更快启动
   >
   > - 丰富的API
   >
   >   支持文件资源的分享连接及分享链接的过期策略、存储桶操作、文件列表访问及文件上传下载的基本功能等。
   >
   > - 文件变化主动通知
   >
   >   存储桶（Bucket）如果发生改变,比如上传对象和删除对象，可以使用存储桶事件通知机制进行监控，并通过以下方式发布出去:AMQP、MQTT、Elasticsearch、Redis、NATS、MySQL、Kafka、Webhooks等。

### 3.2.2 安装使用

> 步骤：
>
> [Docker 搭建 Minio 容器 (完整详细版)_docker minio-CSDN博客](https://blog.csdn.net/BThinker/article/details/125412751)
>
> 1. 拉取镜像
> 2. 创建容器
> 3. 访问minio系统

1. **拉取镜像**

   ```
   docker pull minio/minio
   ```

2. **创建容器**

   我们可以使用docker进行环境部署和启动

   ```yaml
   docker run -p 9000:9000 -p 9090:9090 \
        --net=host \
        --name minio \
        -d --restart=always \
        -e "MINIO_ACCESS_KEY=minioadmin" \
        -e "MINIO_SECRET_KEY=minioadmin" \
        -v /home/minio/data:/data \
        -v /home/minio/config:/root/.minio \
        minio/minio server \
        /data --console-address ":9090" -address ":9000"
   ```

3. **访问minio系统**

   [http://192.168.200.130:9000](http://192.168.200.130:9000/)



#### 3.2.2.1 创建工程，导入pom依赖

> 步骤： 
>
> 1. 引入依赖
> 2. 创建测试类

创建minio-demo,对应pom如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>heima-leadnews-test</artifactId>
        <groupId>com.heima</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>minio-demo</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>

        <dependency>
            <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>7.1.0</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
    </dependencies>

</project>
```

创建测试类，上传html文件

```java
package com.heima.minio.test;

import io.minio.MinioClient;
import io.minio.PutObjectArgs;

import java.io.FileInputStream;

public class MinIOTest {


    public static void main(String[] args) {

        FileInputStream fileInputStream = null;
        try {

            fileInputStream =  new FileInputStream("D:\\list.html");;

            //1.创建minio链接客户端
            MinioClient minioClient = MinioClient.builder().credentials("minio", "minio123").endpoint("http://192.168.200.130:9000").build();
            //2.上传
            PutObjectArgs putObjectArgs = PutObjectArgs.builder()
                    .object("list.html")//文件名
                    .contentType("text/html")//文件类型
                    .bucket("leadnews")//桶名词  与minio创建的名词一致
                    .stream(fileInputStream, fileInputStream.available(), -1) //文件流
                    .build();
            minioClient.putObject(putObjectArgs);

            System.out.println("http://192.168.200.130:9000/leadnews/ak47.jpg");

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}
```



### 3.2.3 封装MinIO为starter

> 







# 4 SQL表

## 4.1 垂直分表

> **概念**:
>
> ​	将一个表的字段分散到多个表中，每个表存储其中一部分字段
>
> **优势**： 
>
> 1. 减少io争抢，减少锁表几率，查看文章概述与文档详情互不影响
> 2. 充分发挥高频数据的操作效率，对文章概述数据操作的高效率不会被操作文章详情数据的低效率所拖累
>
> **拆分规则**：
>
> 1. 不常用的字段单独放在一张表
> 2. 大字段拆分出来单独放在一张表
> 3. 经常组合查询的字段单独放在一张表





# 附录：工具类用法

## 1 DigestUtils

> Spring的加密工具类
>
> 背景：
>
> ​	需要将**数据库中的salt+用户输入的password**字符串拼接后进行md5加密然后和数据库中的密码进行对比
>
> ```java
>             String salt = dbUser.getSalt();
>             String password = dto.getPassword();
>             String pswd = DigestUtils.md5DigestAsHex((password + salt).getBytes());
>             if (pswd.equals(dbUser.getPassword())) {
>                 return ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_PASSWORD_ERROR);
>             }
> ```
>
> > 这里的salt是数据库中的，password是用户输入的，dbUser是数据库中的
