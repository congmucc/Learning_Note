[学习教程](https://github.com/ABCDELabs/Understanding-Ethereum-Go-version)

# 0、初始问题回答ing

**Miner 是从什么方式获取到待打包的 Transactions?**

矿工（Miner ）从交易池（Transaction Pool）中获取待打包的交易。交易池是一个存储尚未被打包到区块中的交易的集合，通常称为内存池（Mempool）。

**Miner 是基于什么样策略从 Transaction Pool 中选择 Transaction 呢？**

矿工基于以下策略从交易池中选择交易：

1. **Gas 价格（Gas Price）**：矿工通常优先选择 Gas 价格较高的交易，因为这些交易会带来更高的手续费。
2. **交易的复杂性和大小**：交易的复杂性和大小也会影响选择策略。复杂或大的交易可能会被延后处理。
3. **交易的依赖关系**：如果某些交易相互依赖（例如 A 交易是 B 交易的输入），矿工会确保这些交易的顺序。

**被选择的 Transactions 又是以怎样的顺序(Order)被打包到区块中的呢？**

矿工根据上述策略选择交易后，通常按照以下顺序打包交易：

1. **按 Gas 价格从高到低排序**：以确保矿工获得最高的手续费。
2. **确保交易的依赖关系**：如果某些交易存在依赖关系，矿工会确保它们按正确的顺序打包。

**在执行 Transaction 的 EVM 是怎么计算 gas used，从而限定 Block 中 Transaction 的数量?**

在 EVM 中，每个操作码（Opcode）都有一个固定的 Gas 消耗。当一个交易被执行时，EVM 会逐步执行交易中的操作码，并累计消耗的 Gas。每个区块都有一个最大 Gas 限制（Gas Limit），交易执行总消耗的 Gas 不能超过这个限制。如果在执行交易过程中耗尽了 Gas，交易会失败，但已经消耗的 Gas 不会退还。

**剩余的 gas 又是怎么返还给 Transaction Proposer 的呢？**

当交易成功执行且未耗尽提供的 Gas 时，剩余的 Gas 会被返还给交易的发起者（Proposer）。返还过程如下：

1. 计算实际消耗的 Gas。
2. 用交易中指定的 Gas 价格乘以实际消耗的 Gas，计算实际的手续费。
3. 剩余的 Gas 乘以 Gas 价格，返还给交易发起者。

**EVM 是怎么解释 Contract Code 的 Message Call 并执行的呢？**

EVM 解释和执行智能合约代码时，会处理消息调用（Message Call）：

1. **解析输入数据**：根据智能合约 ABI 解析输入数据，确定要调用的函数及其参数。
2. **执行函数**：根据智能合约代码的字节码（Bytecode），逐步执行相应的操作码。
3. **修改状态**：执行过程中，会根据函数逻辑读取和修改智能合约的存储变量。
4. **返回结果**：函数执行完毕后，将结果返回给调用者。

**在执行 Transaction 时，是什么模块，怎样去修改 Contract 中持久化变量？**

在 EVM 中，智能合约的持久化变量存储在合约的存储空间（Storage）中。执行交易时，EVM 通过以下步骤修改持久化变量：

1. **加载变量**：从存储空间加载当前值。
2. **执行逻辑**：根据交易中的操作码修改变量值。
3. **存储结果**：将修改后的值写回存储空间。

**Smart Contract 中的持久化变量是以什么样的形式存储？又是存储在什么地方？**

智能合约的持久化变量以键值对（Key-Value）的形式存储在合约的存储空间中。具体来说：

- **键（Key）**：通常是变量的哈希值。
- **值（Value）**：变量的实际值。 这些键值对存储在区块链的状态数据库（State Database）中。

**当新的 Block 更新到 Blockchain 中时，World State 又是在什么时机，以什么方式更新的呢？**

新的区块被添加到区块链时，世界状态（World State）会在以下时机更新：

1. **交易执行后**：每个交易执行完毕后，EVM 会更新当前世界状态。
2. **区块验证完成后**：当所有交易执行完并且区块被验证通过后，新的世界状态会被持久化。

**哪些数据常驻内存，哪些数据需要保存在 Disk 中呢？**

- 常驻内存的数据
  - 交易池（Mempool）：存储尚未打包的交易。
  - 临时计算结果：EVM 执行过程中产生的临时数据。
- 保存在磁盘的数据
  - 区块链数据：所有区块和交易的历史记录。
  - 状态数据库：合约存储和账户余额等持久化状态。
  - 日志和索引：用于快速检索和验证



# 1、第一章

## 1.1、geth 是什么？

`geth` 是以太坊基金会基于 Go 语言开发以太坊的官方执行层客户端，它实现了 Ethereum 协议(黄皮书)中所有需要的实现的功能模块。我们可以通过启动 `geth` 来运行一个 Ethereum 的节点。在以太坊 Merge 之后，`geth` 作为节点的执行层继续在以太坊生态中发挥重要的作用。 `go-ethereum`是包含了 `geth` 客户端代码和以及编译 `geth` 所需要的其他代码在内的一个完整的代码库。在本系列中我们会通过深入 go-ethereum 代码库，从 High-level 的 API 接口出发，沿着 Ethereum 主 Workflow，逐一的理解 Ethereum 具体实现的细节。

为了方便区分，在接下来的文章中，我们用 `geth` 来表示 go-ethereum 客户端程序，用 `GETH` 来表示 go-ethereum 的代码库。

总结的来说:

1. 基于 `go-ethereum` 代码库中的代码，我们可以编译出 `geth` 客户端程序。
2. 通过运行 `geth` 客户端程序我们可以启动一个 Ethereum 的节点。