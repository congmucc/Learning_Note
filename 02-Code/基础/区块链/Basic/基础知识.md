# 0 介绍

> 1、[js版本区块链学习地址](https://github.com/smartcontractkit/full-blockchain-solidity-course-js?tab=readme-ov-file)

## 0.1 建议

> 三个黑客松，Chainlink、ETHGlobal、Devfolio





## 0.2 什么是web3

Web 3，又称为去中心化的互联网，是一种新兴的网络范式，旨在解决Web 2时代的中心化和隐私问题。它基于区块链和分布式技术，旨在实现更开放、透明和用户主导的网络体验。

**重点特点：**
- **去中心化（这也是围绕在这份知识库的核心理念）：** Web 3的核心概念是去中心化，它不依赖于单一的中心化服务器，而是通过分布式网络节点共同维护和处理数据。
- **区块链技术（我们将会在下面详细介绍）：** 区块链是Web 3的基石，它提供了安全的分布式账本，确保数据的透明性和防篡改性。
- **加密货币：** 加密货币作为交易媒介在Web 3中发挥重要作用，它们使得去中心化的价值交换成为可能。
- **智能合约：** 智能合约是自动执行的代码，能够在不需要中介的情况下进行交易和协议执行。
- **用户数据控制：** Web 3强调用户对自己数据的控制权，用户可以选择共享数据，并从中获益，而不是被中心化平台收集和操控。
- **身份验证与隐私：** Web 3提供了更安全和隐私保护的身份验证方式，确保用户在互联网上的匿名性和隐私。
- **开放协议：** Web 3鼓励开放协议的使用，使不同应用能够相互连接和互操作，从而创造更多样化的网络生态系统。

**重要部分：**
- 区块链技术 是实现Web 3去中心化特性的基础，它确保了数据的安全性和可信性。
- 智能合约让无需第三方干预的可编程交易和协议成为可能，推动了去中心化应用的发展。
- 加密货币 作为Web 3的经济基础，支持用户之间的价值交换，打破了传统金融的壁垒。
- 用户对于个人数据的控制权 强调了隐私保护的重要性，将数据从中心化平台转移到用户手中。
- 开放协议 促进了不同应用的协同工作，创造出更加丰富和创新的网络生态。

## 0.3 Web2与Web3的区别与联系

**区别：**

- **中心化 vs. 去中心化：** Web2是中心化的互联网，由少数大型平台掌控用户数据和内容分发。而Web3则是去中心化的，基于区块链技术，数据和控制权分散在网络参与者之间。
- **数据控制：** Web2时代，用户数据通常由平台收集和控制，而Web3强调用户对个人数据的控制权，数据可以被加密并分散存储，从而保护用户隐私。
- **隐私和安全：** Web2平台存在数据泄露和隐私问题，而Web3使用加密技术保护用户隐私，提供更安全的身份验证和数据传输。
- **价值交换：** Web2中，大多数内容和服务是免费的，平台通过广告获利。而在Web3中，加密货币和智能合约使得用户能够直接交换价值，内容创作者可以通过更直接的方式获得报酬。
- **中介与智能合约：** Web2需要中介机构处理交易，而Web3通过智能合约自动执行交易，减少了中介的需求。

**联系：**

- **区块链技术：** Web3的基础是区块链技术，它确保了数据的安全性和可信性，使得去中心化的网络成为可能。
- **智能合约：** 智能合约是Web3的重要组成部分，它在两者中都起到关键作用，但在Web3中更广泛使用，使得自动化交易和协议成为可能。
- **用户主导：** Web3强调用户对网络的控制，这与Web2时代用户产生内容和互动的趋势相呼应，但Web3赋予了用户更大的控制权。
- **数据隐私：** Web3通过加密技术和去中心化存储保护用户的隐私，这与Web2中隐私问题相对比。
- **开放协议：** Web3鼓励开放协议的使用，使不同应用能够相互连接和互操作，这也反映了Web2时代开放API和互操作性的趋势。



# 1 区块链基础知识



## 1.1 区块链

> 区块链是在计算机网络节点之间共享的分布式数据库或账本。它们以其在加密货币系统中的关键作用而闻名，以维护安全和去中心化的交易记录，但它们不仅限于加密货币的用途。区块链可用于使任何行业的数据不可变，该术语用于描述无法更改。



## 1.2 智能合约

> 智能合约是通过去中心化的方式来执行一些列的指令，在这些指令执行中，并不需要中心化或者第三方的中介。
>
> 

## 1.3 预言机

> 任何可以向区块链输入数据或者进行链下计算的设备

> [常用Chainlink Documentation](https://docs.chain.link/)
>
> Chainlink data feed：是从现实世界中存取定价信息或其他数据的方法
>
> Chainlink VRF：是一种将可证明的随机数从现实世界获取到智能合约中的方法
>
> Chainlink Keepers：是一种去中心化驱动事件的方法，设置一些触发器，触发器触发做某事。
>
> Chainlink Any API 是Chainlink节点的终极机制，链接到任何事物。

## 1.4 gas

> gas是一个计算量单位，要使用更多的计算资源，就需要支付更多的gas

**youtube上gas总结、交易过程讲解**

*[https://youtu.be/gyMwXuJrbJQ?t=5804](https://youtu.be/gyMwXuJrbJQ?t=5422)*



## 1.5 区块链原理

> - 哈希
> - 区块
> - 签名

**区块链是如何工作的**：

- [Blockchain Demo (andersbrownworth.com)](https://andersbrownworth.com/blockchain/)

**签名交易**：

*[⌨️ (01:22:55) Signing Transactions
⌨️ （01：22：55） 签署事务](https://youtu.be/gyMwXuJrbJQ?t=4975)*

- [Public / Private Keys
  公钥/私钥](https://andersbrownworth.com/blockchain/public-private-keys/keys)
- [Layer 2 and Rollups
  第 2 层和汇总](https://ethereum.org/en/developers/docs/scaling/layer-2-rollups/)
- [Decentralized Blockchain Oracles
  去中心化区块链预言机](https://blog.chain.link/what-is-the-blockchain-oracle-problem/)



## 1.6 高级区块链基础知识

- [Consensus 共识](https://wiki.polkadot.network/docs/learn-consensus)
  - [Proof of Stake 权益证明](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)
  - [Proof of Work 工作量证明](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/)

> 共识可分为 
>
> - 1、Chain Selection   
> - 2、Sybil Resistance

> 对于2 在以太坊2.0时代，工作量证明是2的机制，来找到谁挖出了区块，哪一个节点，才是做了运算，然后挖出区块的节点。最终防止用户使用大量的假身份，然后影响区块链中的数据的对错。

以太坊2.0   使用的是权益证明和分片

TODO



## 1.7 区块链发送参数

**Nonce**: tx count for the account

**Gas Price**: price per unit of gas (in wei)

**Gas Limit**: max gas that this tx can use

**To**: address that the tx is sent to

**Value**: amount of wei to send

**Data**: what to send to the To address

**v, r, s**: components of tx signature

# 2 Solidity

## 2.1 基本语法

### 2.1.1 数据类型

1、**boolean**

2、**unit**

> 正数，跟c++的类似。这个比较特殊，当定义变量的时候可以使用`unit8`-`unit256`其中的数，单位是8（一个字节8比特），默认是256.
>
> `uint256 favoriteNumber = 5;`

3、**int**

> 跟unit的特殊相同，可以使用`int256`定义变量。
>
> `int256 favoriteNumber = -5;`

4、**address**

> 地址，跟metamask中的个人地址一样，类似id这种的唯一标识。
>
> `address myAddress = 0x1066618d189731Fe13897cC1;`

5、**bytes**

> 同uint特殊。
>
> `bytes32 favoriteBytes = "cat";`

6、**stirng**

>`string favoriteNumberIntext = "five";`

7、**struct**

> 结构体
>
> ```solidity
>     People public people = People({favoriteNumber: 2, name: "congmu"});
> 
>     struct People {
>         uint256 favoriteNumber;
>         string name;
>     }
> ```

8、**数组类型**

> ```solidity
>    People[] public people;
>     //添加数组元素
>     function addPeople(string memory _name, uint256 _favoriteNumber) public {
>         People memory newPeople = People({favoriteNumber: _favoriteNumber, name: _name});
>         people.push(newPeople);
>     }
> ```

9、**映射mapping**

> ```solidity
>     mapping(string => uint256) public nameToFavoriteNumber;
>         //添加数组元素
>     function addPeople(string memory _name, uint256 _favoriteNumber) public {
>         nameToFavoriteNumber[_name] = _favoriteNumber;
>     }
> ```

### 2.1.2 功能可见性说明符

- `public` ：在外部和内部可见（为存储/状态变量**创建 getter 函数**）
- `private` ：仅在当前合约中可见
- `external` ：仅在外部可见（仅对函数） - 即只能通过消息调用（通过 `this.func` ）
- `internal` ：仅在内部可见



### 2.1.3 修饰符(关键字)

- `pure` for functions：不允许修改或访问状态。
- `view` for functions：不允许修改状态。

- `payable` for functioins： 是一个关键字和修饰符，用于指示函数或合约可以接收以太币（Ether）或发送以太币。

> 1、**代码示例**
>
> ```solidity
>    function getFavoriteNumber() public view returns(uint256) {
>         return favoriteNumber;
>     } 
> ```
>
> 2、**注意**
>
> 1. `pure`和`view`标识的调用不需要消耗gas，因为只有更改状态的时候才支付gas。除非在消耗gas的函数中调用`view`和`pure`标识的函数才会使被标识的函数消耗gas。



### 2.1.4 可存储数据

1、**Stack**

> 不能被修改的临时变量

2、**Memory**

> 可以被修改的临时变量

3、**Storage**

> 可以被修改的永久变量

4、**Calldata**

5、**Code**

6、**Logs**

> **结构体**、**映射**和**数组**在作为参数被添加到不同函数时需要给定一个`memory`或`calldata`关键字



### 2.1.5 库Library

> 场景是将自己写的函数作为别的函数库
>
> 例如将ETH和USD转换封装成库，使用msg.value.getConversionRate()调用
>
> 步骤：
>
> 1、将**转换的函数**以及**相关导入**创建一个`library`封装起来，记得函数可见性改为`internal`
>
> 2、主合约导入库，并使用语句`using A for B`来进行调用

1、

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";


library PriceConverter {
    
    function getPrice() internal view returns (uint256) {
        // ABI
        // Address  0x694AA1769357215DE4FAC081bf1f309aDC325306
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
        (,int256 price, , , ) = priceFeed.latestRoundData();
        // // ETH in terms of usd
        
        return uint256(uint256(price) * (10*(18 - uint(priceFeed.decimals()))));
    }

    function getVersion() internal view returns (uint256) {
        AggregatorV3Interface priceV = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
        return priceV.version();
    }

    function getConversionRate(uint256 ethAmount) internal view returns (uint256) {
        uint256 ethPrice = getPrice();
        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;
        return ethAmountInUsd;
    }
}
```

2、

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import "./PriceConverter.sol";

contract FundMe {

    using PriceConverter for uint256;

    uint256 public minimumUsd = 50 * 1e18;


    address[] public funders;

    mapping(address => uint256) public addressToAmountFunded;

    function fund() public payable  {
        // number = 5; // 如果require出现error了，这段代码也会被回退
        // require(getConversionRate(msg.value) >= minimumUsd, "Didn't send enough"); // 1e18 == 1 * 10 ** 18
        require(msg.value.getConversionRate() >= minimumUsd, "Didn't send enough"); // 1e18 == 1 * 10 ** 18
        funders.push(msg.sender);
        addressToAmountFunded[msg.sender] = msg.value;
    }


    // function withdraw() {}
}
```

> `using PriceConverter for uint256;` 语句将 `PriceConverter` 库中的功能引入了 `uint256` 类型，使得 `uint256` 类型的变量可以直接调用 `PriceConverter` 中定义的函数。





## 2.2 面向对象

> 合约的关键字是`contract`， 类似java的`calss`



### 2.2.1 封装

```solidity
// I'm a comment!
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.8;
// pragma solidity ^0.8.0;
// pragma solidity >=0.8.0 <0.9.0;

contract SimpleStorage {

    uint256 favoriteNumber;

    struct People {
        uint256 favoriteNumber;
        string name;
    }
    // uint256[] public anArray;
    People[] public people;

    mapping(string => uint256) public nameToFavoriteNumber;

    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
    }
    
    function retrieve() public view returns (uint256){
        return favoriteNumber;
    }

    function addPerson(string memory _name, uint256 _favoriteNumber) public {
        people.push(People(_favoriteNumber, _name));
        nameToFavoriteNumber[_name] = _favoriteNumber;
    }
}

```

> 就是正常的写函数



### 2.2.2 继承

#### 2.2.2.1 继承

```solidity
import "./SimpleStorage.sol";

contract ExtraStorage is SimpleStorage{

}
```

> 关键词是`is`，使用前需要导入

#### 2.2.2.2 重载

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.8;


contract SimpleStorage {

    uint256 favoriteNumber;
    function store(uint256 _favoriteNumber) public virtual {
        favoriteNumber = _favoriteNumber;
    }
}
```

> 父类合同  需要加`virtual`关键字



```solidity
pragma solidity ^0.8.7;

import "./SimpleStorage.sol";

contract ExtraStorage is SimpleStorage{
        function store(uint256 _favoriteNumber) public override {
            favoriteNumber = _favoriteNumber + 5;
        }
}
```

> 子类合同  需要加 `override`关键字





##  2.3 高级

### 2.3.1 chainlink的使用

在实战3.1中，需要同故宫chainlink获取ETH和USD汇率转换需要使用Data Feed

[ETH / USD | Chainlink界面](https://data.chain.link/streams/arbitrum/mainnet/eth-usd) [Using Data Feeds 开发文档](https://docs.chain.link/data-feeds/using-data-feeds)







# 3 实战

## 3.1 04发送一个合约交易

```solidity
// SPDX-License-Indentifitier: MIT
pragma solidity ^0.8.8;

contract FundMe {

    uint256 public minimumUsd = 50;

    function fund() public payable  {
        // number = 5; // 如果require出现error了，这段代码也会被回退
        
        require(msg.value >= minimumUsd, "Didn't send enough"); // 1e18 == 1 * 10 ** 18
    }

    // function withdraw() {}
}
```

> 功能：
>
> 1、payable
>
> 2、msg.value
>
> > 这个意思是获取发送合约时的`value`
>
> 3、`require(A,B)`
>
> > 这是一个用于判断的函数，如果A == false 则控制台报错B
> >
> > 并且会回退前面的代码，如`number = 5`
>
>  
>
> 网站：
>
> [Data feed](# 2.3.1 chainlink的使用)
