## 2.1 B+树

1、 [美团二面：B树和B+树有什么区别？为什么MySQL要选择B+树作为索引数据结构，而不是B树 ？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV19K421b7PX/)

b和b+区别：

> 1、 B+数据存在在叶子节点，B树数据存在于所有节点
>
> 2、B+叶子节点有双向链表
>
> 3、B+树所有索引和数据都在叶子节点，B树叶子节点没有‘分支节点’





## 2.2 各种锁：

[【原创】惊！史上最全的select加锁分析(Mysql) - 孤独烟 - 博客园 (cnblogs.com)](https://www.cnblogs.com/rjzheng/p/9950951.html)

### 2.2.1 基础知识

**共享锁**(S锁):

> 假设事务T1对数据A加上共享锁，那么事务T2**可以**读数据A，**不能**修改数据A。其他事务只能再对A加S锁，而不能加X锁

**排他锁**(X锁):

> 假设事务T1对数据A加上共享锁，那么事务T2**不能**读数据A，**不能**修改数据A。其他事务不能再对A加任何锁，直到T释放A上的锁，

> 我们通过`update`、`delete`等语句加上的锁都是行级别的锁。只有`LOCK TABLE … READ`和`LOCK TABLE … WRITE`才能申请表级别的锁。

**意向共享锁**(IS锁):

> 一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。

**意向排他锁**(IX锁):

> 一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。





**事务的四个隔离级别、他们由弱到强如下所示:**

- `Read Uncommited(RU)`：读未提交，一个事务可以读到另一个事务未提交的数据！
- `Read Committed (RC)`：读已提交，一个事务可以读到另一个事务已提交的数据!
- `Repeatable Read (RR)`:可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免!我会在下一篇文章说明!另外就是记住从该级别才开始加入间隙锁(这句话记下来，后面有用到)!
- `Serializable`：串行化，该级别下读写串行化，且所有的`select`语句后都自动加上`lock in share mode`，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。



### 2.2.2 实际操作关于锁的情况

**Select**

那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的，

> **InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

**错误一**:并不是用表锁来实现锁表的操作，而是利用了`Next-Key Locks`，也可以理解为是用了行锁+间隙锁来实现锁表的操作!
为了便于说明，我来个例子，假设有表数据如下，pId为主键索引

**错误二**:所有文章都不提隔离级别！
之所以能够锁表，是通过行锁+间隙锁来实现的。那么，`RU`和`RC`都不存在间隙锁，这种说法在`RU`和`RC`中还能成立么？
因此，该说法只在`RR`和`Serializable`中是成立的。如果隔离级别为`RU`和`RC`，无论条件列上是否有索引，都不会锁表，只锁行！











